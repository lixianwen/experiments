package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

// GZIP compresses directory named src to a compressed tar file named src.tar.gz.
// It returns the first error encountered while compressing, if any.
// A successful compress returns err == nil
func GZIP(src string) error {
	target, err := os.Create(fmt.Sprintf("%s.tar.gz", src))
	if err != nil {
		slog.Error("create target", "err", err)
		return err
	}
	defer target.Close()

	gw := gzip.NewWriter(target)
	defer gw.Close()
	tw := tar.NewWriter(gw)
	defer tw.Close()

	err = filepath.Walk(src, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			slog.Error("err param", "err", err)
			return err
		}

		if info.IsDir() {
			return nil
		}

		// target platform: Linux
		path = strings.ReplaceAll(path, "\\", "/")

		hdr, err := tar.FileInfoHeader(info, "")
		if err != nil {
			slog.Error("tar.FileInfoHeader", "err", err)
			return err
		}

		// Since info.Name() only returns base name of the file,
		// we need to set the full path to header's Name field otherwise we get a flat tar file without directory structures.
		hdr.Name = path

		if err := tw.WriteHeader(hdr); err != nil {
			slog.Error("tw.WriteHeader", "err", err)
			return err
		}

		f, err := os.Open(path)
		if err != nil {
			slog.Error("os.Open", "err", err)
			return err
		}
		defer f.Close()

		if _, err := io.Copy(tw, f); err != nil {
			slog.Error("io.Copy", "err", err)
			return err
		}

		return nil
	})

	return err
}

// Archive compresses a series of directory to a single tar file and return it.
// After finishing with the tar file, it is the caller's responsibility to call Remove to clean up the temporary files generated by GZIP.
func Archive(directories ...string) (string, error) {
	var wg sync.WaitGroup
	errCH := make(chan error)
	done := make(chan string, len(directories))
	dst := fmt.Sprintf("%s.tar", time.Now().Format("20060102150405"))

	for _, src := range directories {
		wg.Add(1)
		go func(src string) {
			defer wg.Done()

			if err := GZIP(src); err != nil {
				errCH <- err
			} else {
				done <- fmt.Sprintf("%s.tar.gz", src)
			}
		}(src)
	}

	go func() {
		wg.Wait()
		close(done)

		// one failed, others succeeded
		if len(done) != cap(done) {
			return
		}

		// all succeeded
		target, err := os.Create(dst)
		if err != nil {
			slog.Error("create single tar file", "err", err)
			errCH <- err
			return
		}
		defer target.Close()

		tw := tar.NewWriter(target)
		defer tw.Close()
		for fn := range done {
			f, err := os.Open(fn)
			if err != nil {
				slog.Error("open", "filename", fn, "err", err)
				errCH <- err
				return
			}
			defer f.Close()

			info, err := f.Stat()
			if err != nil {
				slog.Error("call stat on fn", "filename", fn, "err", err)
				errCH <- err
				return
			}

			hdr, err := tar.FileInfoHeader(info, "")
			if err != nil {
				slog.Error("get fn's header", "filename", fn, "err", err)
				errCH <- err
				return
			}

			if err := tw.WriteHeader(hdr); err != nil {
				slog.Error("write header to tar file", "filename", fn, "err", err)
				errCH <- err
				return
			}

			if _, err := io.Copy(tw, f); err != nil {
				slog.Error("copy f's content to tar file", "filename", fn, "err", err)
				errCH <- err
				return
			}
		}
		close(errCH)
	}()

	return dst, <-errCH
}

// Remove removes a slice of tar files in the current directory.
func Remove(filenames ...string) {
	for _, fn := range filenames {
		slog.Info("cleanup", "rm", fn)
		if err := os.Remove(fn); err != nil {
			slog.Warn("cleanup", "rm", fn, "err", err)
		}
	}
}
